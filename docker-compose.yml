version: "3.8"

volumes:
    n8n_storage:
    ocr_uploads:
    redis_data:

services:
    redis:
        image: redis:7-alpine
        restart: always
        volumes:
            - redis_data:/data
        networks:
            - app-network

    n8n:
        image: n8nio/n8n:latest
        container_name: n8n-ocr-pipeline-n8n-1
        restart: always
        env_file:
            - .env
        environment:
            - N8N_USER_EMAIL=${N8N_USER_EMAIL}
            - N8N_USER_FIRSTNAME=${N8N_USER_FIRSTNAME}
            - N8N_USER_LASTNAME=${N8N_USER_LASTNAME}
            - N8N_USER_PASSWORD=${N8N_USER_PASSWORD}
            - N8N_TRUST_PROXY=true
            - N8N_IP_WHITELIST=0.0.0.0/0,::/0
            - WEBHOOK_URL=${NGROK_WEBHOOK_URL}
            - NGROK_WEBHOOK_URL=${NGROK_WEBHOOK_URL}
            - CONFIDENCE_LOW_ALERT_MAIL=${CONFIDENCE_LOW_ALERT_MAIL}
            - GOOGLE_SHEET_URL=${GOOGLE_SHEET_URL}
            - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
            - N8N_RUNNERS_ENABLED=true
            # 修復權限和配置警告
            - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
            - N8N_RUNNERS_ENABLED=true
            
        volumes:
            - n8n_storage:/home/node/.n8n
            - ./workflows:/workflows 
        networks:
            - app-network
        depends_on:
            - redis
        
        healthcheck:
            test: ["CMD-SHELL", "wget -q --spider -S \"http://localhost:5678/healthz\" || exit 1"]
            interval: 10s
            timeout: 5s
            retries: 10
    n8n-init:
        build:
            context: ./n8n-init
        
        volumes:
            # ★★★ 挂载 Docker socket，让容器可以执行 docker 指令 ★★★
            - /var/run/docker.sock:/var/run/docker.sock
        environment:
            - N8N_USER_EMAIL=${N8N_USER_EMAIL}
            - N8N_USER_FIRSTNAME=${N8N_USER_FIRSTNAME}
            - N8N_USER_LASTNAME=${N8N_USER_LASTNAME}
            - N8N_USER_PASSWORD=${N8N_USER_PASSWORD}
            - CONFIDENCE_LOW_ALERT_MAIL=${CONFIDENCE_LOW_ALERT_MAIL}
            - GOOGLE_SHEET_URL=${GOOGLE_SHEET_URL}
        networks:
            - app-network
        depends_on:
            n8n:
                condition: service_healthy # 等待 n8n 完全健康后才启动
        restart: "no" # 这是一个一次性任务
    

    ocr-service:
        build:
            context: .
            dockerfile: Dockerfile.ocr
        restart: always
        volumes:
            - ocr_uploads:/app/uploads
        environment:
            - FLASK_ENV=${FLASK_ENV}
            - FLASK_DEBUG=${FLASK_DEBUG}
            - REDIS_URL=redis://redis:6379/0
            - GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}
        networks:
            - app-network
        depends_on:
            - redis

    celery-worker:
        build:
            context: .
            dockerfile: Dockerfile.ocr
        restart: always
        command: python -u -m celery -A celery_config.celery_app worker --loglevel=info --concurrency=4
        volumes:
            - ocr_uploads:/app/uploads
        environment:
            - REDIS_URL=redis://redis:6379/0
            - PYTHONUNBUFFERED=1
            - PYTHONWARNINGS=ignore
            - OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
            - GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}
        networks:
            - app-network
        depends_on:
            - redis

    nginx:
        image: nginx:alpine
        restart: always
        ports:
            - "8080:80"
        volumes:
            - ./nginx.conf:/etc/nginx/nginx.conf
        networks:
            - app-network
        depends_on:
            - n8n
            - ocr-service

    ngrok:
        image: ngrok/ngrok:latest
        restart: unless-stopped
        command:
            - "http"
            - "--url=${NGROK_URL}"
            - "nginx:80"
        environment:
            - NGROK_AUTHTOKEN=${NGROK_AUTHTOKEN}
        ports:
            - "4040:4040"
        networks:
            - app-network
        depends_on:
            - nginx

    
networks:
    app-network:
        driver: bridge